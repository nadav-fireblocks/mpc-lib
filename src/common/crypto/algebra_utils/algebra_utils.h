#ifndef __ALGEBRA_UTILS_H__
#define __ALGEBRA_UTILS_H__

#include <stdint.h>
#include <openssl/bn.h>
#include "crypto/elliptic_curve_algebra/elliptic_curve_algebra_status.h"
#include "cosigner_export.h"

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

/**
 * @brief Generates a "tough prime" number of the specified bit size.
 * 
 * A tough prime is a large prime generated by multiplying sub-primes together
 * and adding one, ensuring the generated prime is robust against factorization attacks.
 * Unlike safe primes, tough primes do not necessarily have a large prime-order subgroup,
 * but they do ensure the existence of a prime-order subgroup of at least the smallest
 * sub-prime factor used in their construction. This makes them useful in cryptographic
 * applications where resistance to factorization is important.
 * If the bit size is too small, a safe prime (p = 2q + 1) is generated instead.
 * 
 * A tough prime will always be congruent to 3 mod 4. If the caller requests a tough prime
 * that is congruent to 1 mod 4, the function will loop indefinitely, similar to the behavior
 * of OpenSSL's prime number generation function when an unreachable condition is specified.
 * 
 * @param[out] p                  Pointer to the BIGNUM that will store the generated prime.
 * @param[in]  bitsize            The desired bit size of the generated prime.
 * @param[in]  subprimes_bitsize  The bit size of the sub-primes used in the composition.
 * @param[in]  add                (Optional) Additional parameter for residue class (modulus).
 * @param[in]  rem                (Optional) Remainder for the residue class.
 * @param[in]  ctx                Pointer to the BN_CTX context for efficient BIGNUM memory allocation.
 * 
 * @return ELLIPTIC_CURVE_ALGEBRA_SUCCESS on success.
 *         ELLIPTIC_CURVE_ALGEBRA_INVALID_PARAMETER if any input parameter is NULL or invalid.
 *         ELLIPTIC_CURVE_ALGEBRA_OUT_OF_MEMORY if memory allocation fails.
 *         ELLIPTIC_CURVE_ALGEBRA_UNKNOWN_ERROR if prime generation fails after all attempts.
 * 
 * @note 
 * - The `bitsize` must be divisible by `subprimes_bitsize` (`bitsize % subprimes_bitsize == 0`).
 *   If this condition is not met, the function returns an invalid parameter error.
 * - If `bitsize < 4 * subprimes_bitsize`, a safe prime is generated instead of a tough prime.
 * - If `add` and `rem` are NULL, the generated prime will be congruent to 3 (mod 4) for better performance.
 * - The function ensures that the number of sub-primes does not exceed 1024 to prevent excessive memory usage.
 * - The function uses up to `PRIME_GENERATION_MAX_TRIES` attempts per cycle to form a valid prime.
 * - The composite prime is validated using a probabilistic prime test (`BN_is_prime_fasttest_ex`).
 * 
 * @details
 * The function allocates a pool of sub-primes and forms a composite prime by multiplying them together.
 * To ensure randomness, a pseudo-random permutation of sub-primes is generated during each cycle.
 */
COSIGNER_EXPORT elliptic_curve_algebra_status generate_tough_prime(BIGNUM* p, const uint32_t bitsize, const uint32_t subprimes_bitsize, const BIGNUM* add, const BIGNUM* rem, BN_CTX* ctx);

/**
 * @brief Recombines values modulo p and q using the Chinese Remainder Theorem (CRT).
 * 
 * This function recombines values `mod_p` (mod `p`) and `mod_q` (mod `q`) to produce a result modulo `pq = p * q`.
 * The recombination is optimized using the precomputed inverse `q_inv_p = q^(-1) mod p`.
 * 
 * @param[out] out     Pointer to the BIGNUM that will store the recombined result (mod `pq`).
 * @param[in]  mod_p   The result (mod `p`).
 * @param[in]  p       The prime modulus `p`.
 * @param[in]  mod_q   The result (mod `q`).
 * @param[in]  q       The prime modulus `q`.
 * @param[in]  q_inv_p The inverse of `q` modulo `p` (precomputed).
 * @param[in]  pq      The product `p * q`.
 * @param[in]  ctx     Pointer to the BN_CTX context for efficient BIGNUM memory allocation.
 * 
 * @return ELLIPTIC_CURVE_ALGEBRA_SUCCESS on successful recombination.
 *         ELLIPTIC_CURVE_ALGEBRA_INVALID_PARAMETER if any input parameter is NULL.
 *         ELLIPTIC_CURVE_ALGEBRA_UNKNOWN_ERROR if an internal error occurs.
 * 
 * @note 
 * - It is assumed that `p` and `q` are coprime (gcd(p, q) = 1).
 * - The function asserts that the given values satisfy the CRT conditions.
 * - Constant-time operations are used for sensitive modular arithmetic.
 */
COSIGNER_EXPORT elliptic_curve_algebra_status crt_recombine(BIGNUM* out, const BIGNUM* modP, const BIGNUM* p, const BIGNUM* modQ, const BIGNUM* q, const BIGNUM* qinvp, const BIGNUM* pq, BN_CTX* ctx);

/**
 * @brief Computes modular exponentiation using the Chinese Remainder Theorem (CRT).
 * 
 * This function calculates `base^expo mod pq`, where `pq = p * q`. It computes 
 * the result modulo `p` and `q` separately, and then recombines the results using `crt_recombine`.
 * 
 * @param[out] out     Pointer to the BIGNUM that will store the result of `base^expo mod pq`.
 * @param[in]  base    The base of the exponentiation.
 * @param[in]  expo    The exponent.
 * @param[in]  p       The prime modulus `p`.
 * @param[in]  q       The prime modulus `q`.
 * @param[in]  q_inv_p The inverse of `q` modulo `p` (precomputed).
 * @param[in]  pq      The product `p * q`.
 * @param[in]  ctx     Pointer to the BN_CTX context for efficient BIGNUM memory allocation.
 * 
 * @return ELLIPTIC_CURVE_ALGEBRA_SUCCESS on success.
 *         ELLIPTIC_CURVE_ALGEBRA_INVALID_PARAMETER if any input parameter is NULL.
 *         ELLIPTIC_CURVE_ALGEBRA_OUT_OF_MEMORY if memory allocation fails.
 *         ELLIPTIC_CURVE_ALGEBRA_UNKNOWN_ERROR if an internal error occurs.
 * 
 * @note 
 * - It is assumed that `p` and `q` are coprime (gcd(p, q) = 1).
 * - The function asserts that `p`, `q`, and `q_inv_p` are marked as constant-time for secure operations.
 * - Uses constant-time exponentiation (`BN_mod_exp`) to avoid side-channel leaks.
 */
COSIGNER_EXPORT elliptic_curve_algebra_status crt_mod_exp(BIGNUM* out, const BIGNUM* base, const BIGNUM* expo, const BIGNUM* p, const BIGNUM* q, const BIGNUM* qinvp, const BIGNUM* pq, BN_CTX* ctx);

/***  WARNING: this function doesn't run in constant time! ****/
/**
 * @brief Checks if two numbers are coprime using the Euclidean algorithm.
 * 
 * This function checks whether `in_a` and `in_b` are coprime by calculating their 
 * greatest common divisor (GCD). If `gcd(in_a, in_b) == 1`, the numbers are coprime.
 * 
 * @param[in] in_a The first input BIGNUM.
 * @param[in] in_b The second input BIGNUM.
 * @param[in] ctx  Pointer to the BN_CTX context for efficient BIGNUM memory allocation.
 * 
 * @return 1 if `in_a` and `in_b` are coprime (GCD is 1).
 *         0 if they are not coprime (GCD is greater than 1).
 *        -1 if an error occurs (e.g., memory allocation failure or NULL inputs).
 * 
 * @note 
 * - This function does not use constant-time operations and may be vulnerable to side-channel attacks.
 * - The function swaps `in_a` and `in_b` if necessary to ensure `in_a >= in_b` for efficient computation.
 * - BN_CTX memory management is used to avoid excessive memory allocation during the GCD computation.
 */
COSIGNER_EXPORT int is_coprime_fast(const BIGNUM *in_a, const BIGNUM *in_b, BN_CTX *ctx);

/**
 * @brief Computes the floor of log base 2 of a 32-bit unsigned integer in constant time.
 *
 * This function returns the position of the highest set bit (MSB) of the input `x`,
 * which corresponds to the greatest integer `y` such that `2^y <= x`.
 *
 * Steps:
 * 1. Bit spreading: `x |= x >> k` (for `k = 1, 2, 4, 8, 16`).
 *    - Propagates the highest set bit to the right, turning all lower bits to `1`.
 * 2. Multiply the result by a special De Bruijn constant `0x07C4ACDDU`.
 *    - This produces a unique 5-bit index for the highest set bit.
 * 3. The top 5 bits of the result (obtained via `>> 27`) are used to index into `deBruijnTable`.
 *    - `deBruijnTable` is a lookup table that stores the bit positions (0 to 31).
 *
 * Edge case:
 * - If `x` is `0`, returns `0` (though `log2(0)` is undefined, it is commonly treated as `0`).
 *
 * Time Complexity: O(1) (constant time due to bit manipulations and lookup).
 * Space Complexity: O(1) (uses a fixed-size lookup table).
 *
 * Example:
 * ```
 * log2_floor(16) = 4  (since 2^4 = 16)
 * log2_floor(999) = 9 (since 2^9 <= 999 < 2^10)
 * ```
 *
 * @param v 32-bit unsigned integer (must be positive for meaningful results).
 * @return uint32_t The floor of log base 2 of `x` (i.e., position of the highest set bit).
 */
COSIGNER_EXPORT uint32_t log2_floor(const uint32_t v);

#ifdef __cplusplus
}
#endif //__cplusplus

#ifndef CONSTEXPR 
#ifdef __cplusplus
#define CONSTEXPR constexpr
#else
#define CONSTEXPR
#endif
#endif

/**
 * @brief Returns the minimal secure exponent size (in bits) for a given RSA key size.
 *
 * This function determines the smallest recommended size for the RSA public exponent 
 * that maintains the security of the corresponding key size. It ensures that the 
 * security of the exponent matches the strength of the RSA modulus (key size).
 *
 * Note:
 * - This function is based on equivalences between RSA key sizes and symmetric security strengths 
 *   as outlined in cryptographic standards (e.g., NIST SP 800-57, ENISA, and ECRYPT-CSA).
 * - For smaller key sizes (â‰¤1024 bits), the exponent size is reduced primarily for testing purposes. 
 *   These sizes are not suitable for modern cryptographic applications.
 *
 * Example:
 * - For a 2048-bit key, the minimal secure exponent size is 112 bits.
 * - For a 4096-bit key, the minimal secure exponent size is 144 bits.
 *
 * References:
 * - NIST SP 800-57 Part 1 Rev 5, Table 2: Security strength equivalence.
 * - ENISA Algorithms, Key Size, and Parameters Report (2014).
 * - ECRYPT-CSA Recommendations (2020).
 * - Academic research on the Number Field Sieve (NFS) for factoring RSA keys.
 *
 * @param key_size RSA key size in bits.
 * @return uint32_t The minimal secure exponent size in bits.
 */
static inline CONSTEXPR uint32_t get_min_secure_exponent_size(const uint32_t key_size)
{
    // Allow small key sizes primarily for testing or legacy purposes.
    // Security equivalence: 80 bits for 1024-bit RSA.
    if (key_size <= 1024)   return 80; // NIST SP 800-57, Table 2; ENISA, Section 2.2.

    // Security equivalence: 112 bits for 2048-bit RSA.
    if (key_size <= 2048)   return 112; // NIST SP 800-57, Table 2; ENISA, Section 2.2.

    // Security equivalence: 128 bits for 3072-bit RSA.
    if (key_size <= 3072)   return 128; // NIST SP 800-57, Table 2; ENISA, Section 2.2.

    // Security equivalence: 144 bits for 4096-bit RSA.
    if (key_size <= 4096)   return 144; // ECRYPT-CSA, Section 4.3.

    // Security equivalence: 192 bits for 7680-bit RSA.
    if (key_size <= 7680)   return 192; // ENISA, Section 2.2; ECRYPT-CSA, Section 4.3.

    // Security equivalence: 256 bits for 15360-bit RSA.
    if (key_size <= 15360)  return 256; // NIST SP 800-57, Table 2; ENISA, Section 2.2.

    // Default to 256 bits for very large key sizes (beyond 15360 bits).
    return 256; // NIST SP 800-57, Table 2.
}


#endif //__ALGEBRA_UTILS_H__ 